use std::{collections::BTreeMap, mem::swap};

use aoclib::read_input;
use rand::{rngs::StdRng, Rng, SeedableRng};
use rayon::iter::{IntoParallelIterator, ParallelIterator};


#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum Gate {
    AND,
    OR,
    XOR
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Connection {
    gate: Gate,
    inputs: (String, String),
    output: String
}

fn evaluate_with_nums(x: u64, y: u64, connections: &Vec<Connection>) -> u64 {
    let mut state: BTreeMap<String, bool> = BTreeMap::new();

    for i in 0..=44 {
        state.insert(format!("x{:0>2}", i), (x >> i) & 1 == 1);
        state.insert(format!("y{:0>2}", i), (y >> i) & 1 == 1);
    }

    let mut iterations = 0;

    let mut unevaluated_connections = connections.clone();

    while !unevaluated_connections.is_empty() {
        iterations += 1;
        
        if iterations > 2000 {
            panic!("probably invalid logic!");
        }

        unevaluated_connections.retain_mut(|connection| {
            let input1 = match state.get(&connection.inputs.0) {
                Some(value) => *value,
                None => return true
            };
            let input2 = match state.get(&connection.inputs.1) {
                Some(value) => *value,
                None => return true
            };
            let output = match connection.gate {
                Gate::AND => input1 && input2,
                Gate::OR => input1 || input2,
                Gate::XOR => input1 ^ input2
            };
            state.insert(connection.output.clone(), output);
            false
        });
    }

    let mut result = 0;

    for (i, (_, value)) in state.range("z".to_string()..).enumerate() {
        result |= (*value as u64) << i;
    }

    result
}

fn main() {
    let input = read_input("input.txt");

    let (start_values_raw, connections_raw) = input.trim_last_newline().split_once("\n\n").unwrap();

    let mut start_values: BTreeMap<String, bool> = BTreeMap::new();

    for line in start_values_raw.lines() {
        let (key, value) = line.split_once(": ").unwrap();
        start_values.insert(key.to_string(), value == "1");
    }
    

    let mut connections: Vec<Connection> = Vec::new();

    for line in connections_raw.lines() {
        let (inputs, output) = line.split_once(" -> ").unwrap();
        let mut components = inputs.split(" ");
        let input1 = components.next().unwrap();
        let gate = components.next().unwrap();
        let input2 = components.next().unwrap();
        let gate = match gate {
            "AND" => Gate::AND,
            "OR" => Gate::OR,
            "XOR" => Gate::XOR,
            _ => panic!("Unknown gate")
        };
        connections.push(Connection {
            gate,
            inputs: (input1.to_string(), input2.to_string()),
            output: output.to_string()
        });
    }

    let mut state: BTreeMap<String, bool> = start_values.clone();

    let mut unevaluated_connections = connections.clone();

    while !unevaluated_connections.is_empty() {
        unevaluated_connections.retain_mut(|connection| {
            let input1 = match state.get(&connection.inputs.0) {
                Some(value) => *value,
                None => return true
            };
            let input2 = match state.get(&connection.inputs.1) {
                Some(value) => *value,
                None => return true
            };
            let output = match connection.gate {
                Gate::AND => input1 && input2,
                Gate::OR => input1 || input2,
                Gate::XOR => input1 ^ input2
            };
            state.insert(connection.output.clone(), output);
            false
        });
    }

    let mut result = 0;

    for (i, (_, value)) in state.range("z".to_string()..).enumerate() {
        result |= (*value as u64) << i;
    }

    println!("{}", result);

    // Solved partially by hand using the hints generated by the following code

    let swaps = vec![("z09", "hnd"), ("z16", "tdv"), ("z23", "bks"), ("tjp", "nrn")];

    for c in connections.iter_mut() {
        for s in swaps.iter() {
            if c.output == s.0 {
                c.output = s.1.to_string();
                break;
            }
            if c.output == s.1 {
                c.output = s.0.to_string();
                break;
            }
        }
    }

    let mut xor1 = BTreeMap::new();
    let mut and1 = BTreeMap::new();

    for connection in connections.iter() {
        if connection.inputs.0.starts_with("x") && connection.inputs.1.starts_with("y")
            || connection.inputs.0.starts_with("y") && connection.inputs.1.starts_with("x") {
            let nr = connection.inputs.0[1..].parse::<u16>().unwrap();
            if connection.gate == Gate::XOR {
                xor1.insert(nr, connection.clone());
            } else {
                and1.insert(nr, connection.clone());
            }
        }
    }

    let mut xor2_back = BTreeMap::new();

    for connection in connections.iter() {
        if connection.output.starts_with("z") {
            let nr = connection.output[1..].parse::<u16>().unwrap();
            if connection.gate == Gate::XOR {
                xor2_back.insert(nr, connection.clone());
            }
        }
    }

    let mut xor2_forw = BTreeMap::new();
    let mut and2 = BTreeMap::new();

    for x in xor1.iter() {
        for c in connections.iter() {
            if c.inputs.0 == x.1.output || c.inputs.1 == x.1.output {
                match c.gate {
                    Gate::XOR => {xor2_forw.insert(x.0, c.clone());},
                    Gate::AND => {and2.insert(x.0, c.clone());},
                    _ =>  println!("output from xor1 ({}) goes into or gate for {}", x.1.output, x.0)
                };
            }
        }
    }

    for i in 1..44 {
        let c2 = xor2_back.get(&i);

        if c2.is_none() {
            print!("no xor2_back for {}", i);
            if let Some(c1) = xor2_forw.get(&i) {
                println!(" forward connection is {}", c1.output);
            } else {
                println!(" forward connection not found");
            }
            continue;
        }
        let c2 = c2.unwrap();

        let c1 = xor2_forw.get(&i);

        if let Some(c1) = c1 {
            if c1 != c2 {
                println!("{} != {}", c1.output, c2.output);
            }
        } else {
            println!("{} not found", c2.output);
        }
    }


    (0..10_000).into_par_iter().for_each(|_| {
        let x = rand::thread_rng().gen_range(0..1<<44);
        let y = rand::thread_rng().gen_range(0..1<<44);
        let result = evaluate_with_nums(x, y, &connections);
        assert_eq!(result, x + y);
    });

    let mut swapped_values = vec![];

    for s in swaps {
        swapped_values.push(s.0);
        swapped_values.push(s.1);
    }

    swapped_values.sort();

    println!("{}", swapped_values.join(","));

}
